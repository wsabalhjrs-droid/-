import fs from "node:fs/promises";
import path from "node:path";
import remarkHeadings from "@vcarl/remark-headings";
import type { ComponentType } from "react";
import { remark } from "remark";
import remarkFrontmatter from "remark-frontmatter";
import remarkParseFrontmatter from "remark-parse-frontmatter";
import { titleCase } from "title-case";
import {
	type ErrorLog,
	type InfoLog,
	logError,
	logWarning,
} from "./errorLogging";
import { catchAllSidebars, type NavCategory, navData } from "./navData";
import { getFullUrlPath } from "./pathSanitization";
import {
	doesIncludeNormalizedPath,
	doNormalizedPathsMatch,
} from "./redirects/pathMethods";

export type BaseSidebarItemData = {
	type?:
		| "doc"
		| "category"
		| "subcategory"
		| "link"
		| "autogenerated"
		| "bucket"
		| "html";
	forceTopLevel?: boolean; // If true, this item should always be at the top level of the sidebar
	forceOverview?: boolean; // If true, render a category's link as an overview item
	label: string;
	className?: string;
	id?: string; // For docs
	link?: { type: SidebarItemData["type"]; id: string };
	href?: string;
	isAutoGenerated?: boolean;
	collapsible?: boolean; // If true, this item can be collapsed in the sidebar
	subDirsCollapsible?: boolean; // If true, all subdirectories can be collapsed
	frontmatter?: any | any[];
	headings?: any | any[];
	icon?: ComponentType;
	explicitSidebarPosition?: number; // If set, this item has an explicit position in the sidebar
};

const errorList: Array<ErrorLog | InfoLog> = [];

export type SidebarItemData = BaseSidebarItemData & {
	items?: Array<string | SidebarItemData | AutogeneratedSidebarGroup>;
	catchAllPath?: string; // If set, this item will be the sidebar for all paths under it
};

export type ProcessedSidebarData = BaseSidebarItemData & {
	items?: ProcessedSidebarData[];
	breadcrumbs?: BreadCrumbItem[];
};

export type AutogeneratedSidebarGroup = {
	type: "autogenerated";
	dirName: string;
	subDirsCollapsible?: boolean; // If true, all subdirectories can be collapsed
};

export type BreadCrumbItem = {
	label: string;
	href: string;
};

const baseContentPath = "./pages/docs";
const hiddenFilePrefixes = ["_"];
const dirsToIgnore = ["img"];

function shouldIgnoreFile(fileName: string) {
	return (
		hiddenFilePrefixes.some((prefix) => fileName.startsWith(prefix)) ||
		dirsToIgnore.includes(fileName.replaceAll("/", "").replaceAll("\\", ""))
	);
}

function getRemarkData(markdown: string): any {
	return remark()
		.use(remarkFrontmatter, ["yaml", "toml"])
		.use(remarkParseFrontmatter)
		.use(remarkHeadings)
		.processSync(markdown);
}

export function getLabelFromDirectoryName(name: string) {
	if (!name) return "";
	// Return a cleaned up version of the last part of the path
	// do/re/mi-fa-so-la -> Mi Fa So La
	return titleCase(
		name
			.replaceAll("\\", "/")
			.split("/")
			.pop()
			?.replaceAll("-", " ")
			.replaceAll("_", " ") || "",
	);
}

/**
 * If no index data, path, title, etc can be pulled from the parent object
 */

export async function getItemsFromDir(
	dirName: string,
	collapsible: boolean = false,
	breadcrumbs: BreadCrumbItem[],
): Promise<ProcessedSidebarData[]> {
	// Remove leading and trailing slashes, and /docs/ if present
	dirName = dirName
		.replace(/^\/docs\//, "")
		.replace(/^\//, "")
		.replace(/\/$/, "");
	const itemsDir = path.join(process.cwd(), baseContentPath, dirName);
	const itemsList: ProcessedSidebarData[] = [];

	try {
		const dir = await fs.opendir(itemsDir);
		for await (const dirent of dir) {
			if (shouldIgnoreFile(dirent.name)) {
				// Skip hidden items
				continue;
			}

			const entityPath = path.join(itemsDir, dirent.name);
			const isFile = (await fs.lstat(entityPath)).isFile();

			// If it's a directory, do this and return early:
			if (!isFile) {
				const searchPath = `${dirName}/${dirent.name}`;

				// It's a directory, so the breadcrumbs just need the
				// name of it
				const newBreadcrumbs = [
					...breadcrumbs,
					{
						label: getLabelFromDirectoryName(entityPath),
						href: "",
					},
				];

				const children: ProcessedSidebarData[] = await getItemsFromDir(
					searchPath,
					collapsible,
					newBreadcrumbs,
				);

				const indexFileData = children.find((item: ProcessedSidebarData) => {
					return item.link?.id && item.link.id === getFullUrlPath(searchPath);
				});

				const filteredChildren = children?.filter(
					(item: any) => item?.link?.id !== indexFileData?.link?.id,
				);

				if (!indexFileData) {
					if (!filteredChildren || filteredChildren.length <= 0) {
						// If no index file and no children, skip this directory
						const error = {
							title: "Empty Directory warning",
							message: `Failed to add empty directory ${entityPath} to sidebar. To be in the sidebar, a directory must have a file or subdirectory with a +Page.md or +Page.mdx file. Prefix a directory's name with _ to hide it from sidebar generation.`,
						};
						logWarning(error);
						errorList.push(error);
						continue;
					}

					// If no index file, it's just a container with a label
					const finalLabel = getLabelFromDirectoryName(entityPath);
					itemsList.push({
						label: finalLabel,
						items: filteredChildren,
						collapsible,
						breadcrumbs: newBreadcrumbs,
					});
					continue;
				}

				// It's a directory with an index file and potentially children
				itemsList.push({
					label:
						indexFileData.frontmatter?.sidebar_label ||
						indexFileData.frontmatter?.title ||
						indexFileData.headings[0]?.value ||
						getLabelFromDirectoryName(entityPath),
					frontmatter: indexFileData.frontmatter,
					explicitSidebarPosition: indexFileData.frontmatter?.sidebar_position,
					link: { id: getFullUrlPath(indexFileData.link?.id), type: "doc" },
					items: filteredChildren,
					collapsible,
					breadcrumbs: newBreadcrumbs,
				});
				continue;
			}

			//If it's a file...

			if (
				!entityPath.endsWith("+Page.mdx") &&
				!entityPath.endsWith("+Page.md")
			) {
				// Skip non-md/mdx files
				continue;
			}

			const markdown = await fs.readFile(entityPath, "utf8");
			const fileOfRemark = getRemarkData(markdown);

			const _finalData = itemsList.push({
				link: {
					type: "doc",
					id: getFullUrlPath(`/docs/${dirName}/${dirent.name}`),
				},
				label:
					fileOfRemark.data?.frontmatter?.sidebar_label ||
					fileOfRemark.data?.frontmatter?.title ||
					fileOfRemark.data?.headings?.find((item: any) => item.depth === 1)
						?.value ||
					getLabelFromDirectoryName(entityPath),
				frontmatter: fileOfRemark.data?.frontmatter,
				headings: fileOfRemark.data?.headings,
				explicitSidebarPosition:
					fileOfRemark.data?.frontmatter?.sidebar_position,
				items: [],
				breadcrumbs,
			});
		}
	} catch (error) {
		// It's a file, not a directory
		const errorData = {
			title: "Sidebar Generation Error",
			message: `Error reading directory ${itemsDir}. Make sure the directory exists and is not empty.`,
			error,
		};
		logError(errorData);
		errorList.push(errorData);
		return itemsList;
	}

	return itemsList;

	// return integrationList.sort((a, b) => a.name.localeCompare(b.name));
}

const getItemFromString = async (
	itemPath: string,
): Promise<ProcessedSidebarData> => {
	// Remove leading and trailing slashes, and /docs/ if present
	itemPath = itemPath
		.replace(/^\/docs\//, "")
		.replace(/^\//, "")
		.replace(/\/$/, "");

	const fullItemPath = path.join(process.cwd(), baseContentPath, itemPath);
	const data = await getSidebarItemAtPath(fullItemPath);
	if (!data) {
		throw new Error(
			`Failed to get sidebar item at path '${fullItemPath}'. Make sure the file exists and ends in .md or .mdx.`,
		);
	}

	return {
		link: { id: getFullUrlPath(data.resolvedPath), type: "doc" },
		type: "doc",
		label:
			data.frontmatter?.sidebar_label ||
			data.frontmatter?.title ||
			data.headings.find((item: any) => item.depth === 1)?.value,
		frontmatter: data.frontmatter,
		items: [],
	};
};

export async function getSidebarItemAtPath(rawPath: string): Promise<{
	frontmatter: any;
	headings: any;
	resolvedPath: string;
} | null> {
	try {
		rawPath = rawPath.replace("index", "");
		let mdxFilePath = `${rawPath}/+Page.mdx`;
		const mdFilePath = `${rawPath}/+Page.md`;
		let markdown = "";
		try {
			try {
				markdown = await fs.readFile(mdxFilePath, "utf8");
			} catch (_error) {
				// Check for .md
				mdxFilePath = "";
				markdown = await fs.readFile(mdFilePath, "utf8");
			}
		} catch (error) {
			const errorData = {
				title: "Path Item error",
				message: `Error getting sidebar item at path ${getFullUrlPath(rawPath)}. Either the file doesn't exist, or it doesn't end in .md or .mdx.`,
			};
			errorList.push({ ...errorData, error });
			logError(errorData);
			return null;
		}

		const fileOfRemark = getRemarkData(markdown);

		return {
			resolvedPath: getFullUrlPath(rawPath.split("/docs/").pop()),
			frontmatter: fileOfRemark.data?.frontmatter,
			headings: fileOfRemark.data?.headings,
		};
	} catch (error) {
		const errorData = {
			title: "Path Item error",
			message: `Error getting sidebar item at path ${rawPath}`,
		};
		logError(errorData);
		errorList.push({ ...errorData, error });
		return null;
	}
}

const getChildrenData = async (
	itemData: SidebarItemData,
	parentBreadcrumbs: BreadCrumbItem[] = [],
) => {
	if (!itemData || !itemData.items || itemData.items.length <= 0) {
		return [];
	}
	const resolvedData = (
		await Promise.allSettled(
			itemData.items.map(async (childData: any) => {
				const childType = typeof childData;
				const newBreadcrumb = {
					label: itemData.label,
					href: getFullUrlPath(
						itemData.link?.id || itemData.id || itemData.href || "",
					),
				};
				const breadcrumbs = parentBreadcrumbs.some(
					(item) => item.label === newBreadcrumb.label,
				)
					? parentBreadcrumbs
					: [...parentBreadcrumbs, newBreadcrumb];
				let processedItem: ProcessedSidebarData | null = null;
				switch (childType) {
					case "string":
						processedItem = await getItemFromString(childData as string);
						break;
					case "object": {
						const collapsible = Boolean(
							itemData.subDirsCollapsible ?? childData.collapsible,
						);
						if (childData?.type === "autogenerated") {
							return await getItemsFromDir(
								childData.dirName,
								collapsible,
								breadcrumbs,
							);
						}
						processedItem = await getItemFromObject(
							{ ...childData, collapsible },
							breadcrumbs,
						);
						break;
					}
				}
				if (!processedItem) return null;
				return {
					...processedItem,
					breadcrumbs,
				};
			}),
		)
	)
		.map((result) => {
			if (result.status === "fulfilled") {
				return result.value;
			}
			return null;
		})
		.filter((item) => item !== null && item !== undefined);

	// Flatten any arrays from autogenerated items before sorting
	const flattenedData = resolvedData.flat() as ProcessedSidebarData[];
	return getSortedItems(flattenedData);
};

const getNavCategoryFromObject = async (
	itemData: NavCategory,
): Promise<ProcessedSidebarData | null> => {
	if (!itemData || !itemData.items || itemData.items.length <= 0) {
		const errorData = {
			title: "Sidebar Category Error",
			message: `Nav category ${itemData.label} has no items. It must have at least one item to be included in the sidebar.`,
		};
		logError(errorData);
		errorList.push(errorData);
		// Return an empty object to avoid breaking the sidebar
		return null;
	}

	const children = await getChildrenData(itemData);

	return {
		...itemData,
		items: children,
	};
};

const getItemFromObject = async (
	itemData: SidebarItemData,
	parentBreadcrumbs: BreadCrumbItem[] = [],
): Promise<ProcessedSidebarData> => {
	const children = itemData.items
		? await getChildrenData(itemData, parentBreadcrumbs)
		: [];

	// const children = childrenData.length > 0 ? childrenData?.map((item: any) => item.value).flat() : childrenData;

	const finalPath =
		itemData.type === "link"
			? ""
			: getFullUrlPath(
					itemData.link?.id ||
						itemData.id ||
						children?.[0]?.link?.id ||
						children?.[0]?.id,
				) || "";

	logErrorIfChildrenInvalid(children, itemData, finalPath);

	return {
		...itemData,
		link: { ...itemData.link, id: finalPath },
		items: children,
		breadcrumbs: parentBreadcrumbs,
	} as ProcessedSidebarData;
};

function logErrorIfChildrenInvalid(
	children: SidebarItemData[],
	itemData: any,
	finalPath: string,
) {
	if (!children || children.length === 0) {
		return;
	}

	// Any sidebar item with type "link" cannot link to the same path as the parent object
	if (
		children.some(
			(item: SidebarItemData) =>
				item?.type === "link" && doNormalizedPathsMatch(item?.href, finalPath),
		)
	) {
		const errorData = {
			title: "Sidebar Item Error",
			message: `Sidebar items with type "link" cannot link to the same path as the parent object. This will cause it to not link properly. Check "${itemData.label}".\n\n Problematic path: ${finalPath}`,
		};
		logError(errorData);
		errorList.push(errorData);
	}
}

/**
 * Make this just work if the item is formatted properly already
 */
export async function getSidebar() {
	return {
		sidebarData: await Promise.allSettled(
			navData.map(async (navCategory: NavCategory) => {
				if (navCategory.type !== "category") {
					const errorData = {
						title: "Nav Data Error",
						message: `Nav category ${navCategory.label} is not a valid category type.`,
					};
					logError(errorData);
					errorList.push(errorData);
					return null;
				}
				if (typeof navCategory !== "object")
					console.error("Top-level nav item must be an object");
				return await getNavCategoryFromObject(navCategory);
			}),
		),
		errorList,
	};
}

export function findInNestedArray(children: any, path: string) {
	if (!children) return null;
	for (const child of children) {
		if (!child) {
			continue;
		}
		// Skip links
		if (child.type === "link") {
			continue;
		}

		if (child.link?.id && doNormalizedPathsMatch(path, child.link?.id)) {
			return child;
		}
		// Recurse if children exist and are an array
		if (Array.isArray(child.items)) {
			const found: ProcessedSidebarData = findInNestedArray(child.items, path);
			if (found) {
				return found;
			}
		}
	}

	return null;
}

export const getActiveNavCategory = (
	windowPath: string,
	sidebarData: ProcessedSidebarData[],
) => {
	// First check if the window path is one of the top-level pages
	const topLevelPage = sidebarData.find((item: ProcessedSidebarData) => {
		return doNormalizedPathsMatch(item?.link?.id, windowPath);
	});
	if (topLevelPage) return topLevelPage;

	// If not, find the first category that has a child with the current path
	const matchingCategory = sidebarData.find(
		(category: ProcessedSidebarData) => {
			return findInNestedArray(category.items, windowPath);
		},
	);

	if (!matchingCategory) {
		// Render the appropriate catch-all sidebar
		// If it exists
		const catchAllSidebar = catchAllSidebars.find(
			(item) => item.path && doesIncludeNormalizedPath(windowPath, item.path),
		);
		if (catchAllSidebar) {
			return sidebarData.find((category: ProcessedSidebarData) => {
				return findInNestedArray(category.items, catchAllSidebar.path);
			});
		}
	}

	return matchingCategory;
};

function getSortedItems(items: ProcessedSidebarData[]) {
	if (
		!items.some(
			(item) => item && item.frontmatter?.sidebar_position !== undefined,
		)
	) {
		// No items with sidebar_position, return original items
		return items;
	}
	const positionedItems: ProcessedSidebarData[] = [];
	for (let i = 0; i < items.length; i++) {
		if (!items[i]) continue;
		if (items[i].frontmatter?.sidebar_position !== undefined) {
			positionedItems.push(items[i]);
		}
	}

	if (positionedItems.length === 0) {
		// No positioned items, return original items
		return items;
	}

	const finalItems: any[] = [];
	finalItems.length = items.length;
	finalItems.fill(null);

	for (const pItem of positionedItems) {
		const pos = pItem.frontmatter.sidebar_position;
		if (!pItem || pos < 0) {
			logError({
				title: "Sidebar Position Error",
				message: `Can't position items using sidebar position ${pItem.frontmatter.sidebar_position} for item ${pItem.label}. Must be greater than 0.`,
			});
			return items; // Return original items if position is invalid
		}
		if (pos < finalItems.length) {
			finalItems[pos] = pItem;
			continue; // If position is within current length, just set it
		}
		// Otherwise, extend array and set position
		finalItems.length = pos + 1;
		finalItems.fill(null, items.length, pos);
		finalItems[pos] = pItem;
	}

	// Turn items into a stack without items from positionedItems
	const itemsStack = items.filter(
		(item) =>
			item && !positionedItems.some((pItem) => pItem.label === item.label),
	);

	// Cycle through finalItems and fill in any nulls with items from the original items array.
	for (let i = 0; i < finalItems.length; i++) {
		if (finalItems[i] !== null && finalItems[i] !== undefined) continue;
		let itemValue: any;
		do {
			itemValue = itemsStack.shift();
		} while (!itemValue && itemsStack.length > 0);
		finalItems[i] = itemValue;
	}

	return finalItems.filter((item) => item !== null && item !== undefined);
}
